// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace WebMap.Networking.Models
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct Map : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Map GetRootAsMap(ByteBuffer _bb) { return GetRootAsMap(_bb, new Map()); }
  public static Map GetRootAsMap(ByteBuffer _bb, Map obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Map __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint RowId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public string Id { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(6); }
  public string Region { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRegionBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetRegionBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetRegionArray() { return __p.__vector_as_array<byte>(8); }
  public string Place { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPlaceBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetPlaceBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetPlaceArray() { return __p.__vector_as_array<byte>(10); }
  public string SubPlace { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSubPlaceBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetSubPlaceBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetSubPlaceArray() { return __p.__vector_as_array<byte>(12); }
  public ushort MapMarkerRange { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  public uint PriorityCategoryUi { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint PriorityUi { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Hierarchy { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public bool DiscoveryArrayByte { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public uint DiscoveryFlag { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public short DiscoveryIndex { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public ushort SizeFactor { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  public short OffsetX { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public short OffsetY { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }

  public static Offset<WebMap.Networking.Models.Map> CreateMap(FlatBufferBuilder builder,
      uint row_id = 0,
      StringOffset idOffset = default(StringOffset),
      StringOffset regionOffset = default(StringOffset),
      StringOffset placeOffset = default(StringOffset),
      StringOffset sub_placeOffset = default(StringOffset),
      ushort map_marker_range = 0,
      uint priority_category_ui = 0,
      uint priority_ui = 0,
      uint hierarchy = 0,
      bool discovery_array_byte = false,
      uint discovery_flag = 0,
      short discovery_index = 0,
      ushort size_factor = 0,
      short offset_x = 0,
      short offset_y = 0) {
    builder.StartTable(15);
    Map.AddDiscoveryFlag(builder, discovery_flag);
    Map.AddHierarchy(builder, hierarchy);
    Map.AddPriorityUi(builder, priority_ui);
    Map.AddPriorityCategoryUi(builder, priority_category_ui);
    Map.AddSubPlace(builder, sub_placeOffset);
    Map.AddPlace(builder, placeOffset);
    Map.AddRegion(builder, regionOffset);
    Map.AddId(builder, idOffset);
    Map.AddRowId(builder, row_id);
    Map.AddOffsetY(builder, offset_y);
    Map.AddOffsetX(builder, offset_x);
    Map.AddSizeFactor(builder, size_factor);
    Map.AddDiscoveryIndex(builder, discovery_index);
    Map.AddMapMarkerRange(builder, map_marker_range);
    Map.AddDiscoveryArrayByte(builder, discovery_array_byte);
    return Map.EndMap(builder);
  }

  public static void StartMap(FlatBufferBuilder builder) { builder.StartTable(15); }
  public static void AddRowId(FlatBufferBuilder builder, uint rowId) { builder.AddUint(0, rowId, 0); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(1, idOffset.Value, 0); }
  public static void AddRegion(FlatBufferBuilder builder, StringOffset regionOffset) { builder.AddOffset(2, regionOffset.Value, 0); }
  public static void AddPlace(FlatBufferBuilder builder, StringOffset placeOffset) { builder.AddOffset(3, placeOffset.Value, 0); }
  public static void AddSubPlace(FlatBufferBuilder builder, StringOffset subPlaceOffset) { builder.AddOffset(4, subPlaceOffset.Value, 0); }
  public static void AddMapMarkerRange(FlatBufferBuilder builder, ushort mapMarkerRange) { builder.AddUshort(5, mapMarkerRange, 0); }
  public static void AddPriorityCategoryUi(FlatBufferBuilder builder, uint priorityCategoryUi) { builder.AddUint(6, priorityCategoryUi, 0); }
  public static void AddPriorityUi(FlatBufferBuilder builder, uint priorityUi) { builder.AddUint(7, priorityUi, 0); }
  public static void AddHierarchy(FlatBufferBuilder builder, uint hierarchy) { builder.AddUint(8, hierarchy, 0); }
  public static void AddDiscoveryArrayByte(FlatBufferBuilder builder, bool discoveryArrayByte) { builder.AddBool(9, discoveryArrayByte, false); }
  public static void AddDiscoveryFlag(FlatBufferBuilder builder, uint discoveryFlag) { builder.AddUint(10, discoveryFlag, 0); }
  public static void AddDiscoveryIndex(FlatBufferBuilder builder, short discoveryIndex) { builder.AddShort(11, discoveryIndex, 0); }
  public static void AddSizeFactor(FlatBufferBuilder builder, ushort sizeFactor) { builder.AddUshort(12, sizeFactor, 0); }
  public static void AddOffsetX(FlatBufferBuilder builder, short offsetX) { builder.AddShort(13, offsetX, 0); }
  public static void AddOffsetY(FlatBufferBuilder builder, short offsetY) { builder.AddShort(14, offsetY, 0); }
  public static Offset<WebMap.Networking.Models.Map> EndMap(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // id
    builder.Required(o, 8);  // region
    builder.Required(o, 10);  // place
    return new Offset<WebMap.Networking.Models.Map>(o);
  }

  public static VectorOffset CreateSortedVectorOfMap(FlatBufferBuilder builder, Offset<Map>[] offsets) {
    Array.Sort(offsets,
      (Offset<Map> o1, Offset<Map> o2) =>
        new Map().__assign(builder.DataBuffer.Length - o1.Value, builder.DataBuffer).RowId.CompareTo(new Map().__assign(builder.DataBuffer.Length - o2.Value, builder.DataBuffer).RowId));
    return builder.CreateVectorOfTables(offsets);
  }

  public static Map? __lookup_by_key(int vectorLocation, uint key, ByteBuffer bb) {
    Map obj_ = new Map();
    int span = bb.GetInt(vectorLocation - 4);
    int start = 0;
    while (span != 0) {
      int middle = span / 2;
      int tableOffset = Table.__indirect(vectorLocation + 4 * (start + middle), bb);
      obj_.__assign(tableOffset, bb);
      int comp = obj_.RowId.CompareTo(key);
      if (comp > 0) {
        span = middle;
      } else if (comp < 0) {
        middle++;
        start += middle;
        span -= middle;
      } else {
        return obj_;
      }
    }
    return null;
  }
}


static public class MapVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*RowId*/, 4 /*uint*/, 4, false)
      && verifier.VerifyString(tablePos, 6 /*Id*/, true)
      && verifier.VerifyString(tablePos, 8 /*Region*/, true)
      && verifier.VerifyString(tablePos, 10 /*Place*/, true)
      && verifier.VerifyString(tablePos, 12 /*SubPlace*/, false)
      && verifier.VerifyField(tablePos, 14 /*MapMarkerRange*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 16 /*PriorityCategoryUi*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*PriorityUi*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*Hierarchy*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*DiscoveryArrayByte*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 24 /*DiscoveryFlag*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 26 /*DiscoveryIndex*/, 2 /*short*/, 2, false)
      && verifier.VerifyField(tablePos, 28 /*SizeFactor*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 30 /*OffsetX*/, 2 /*short*/, 2, false)
      && verifier.VerifyField(tablePos, 32 /*OffsetY*/, 2 /*short*/, 2, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
